중첩 서브루틴 호출, 매개변수 전달, 재귀, 연관 메모리 할당 등....
매우 단순한 데이터 구조로 처리할 수 있는지 보여줄것임

 서브루틴 호출 시 처리해야 할것
 	- 서브루틴으로 매개변수 전달
 	- 실행 전 호출자의 상태 저장
 	- 지역변수에 공간 할당
 	- 실행하기 위해 점프
 	- 결과값을 호출자로 반환
 	- 반환 시, 점유한 메모리 공간을 재활용
 	- 호출자 상태 복구
 	- 이전에 점프 한 지점의 다음 코드를 실행하기 위해 점프
 	
 스택 구조 덕분에 이거는 쉽게 처리 가능함
 
8장에서 프로그램 흐름 제어, 서브루틴 호출 명령을 스택 머신위에서 구현해볼 것임

8.1.1 프로그램 흐름 제어
	하나의 명령어씩 순차적으로 실행, 분기에서 끊어짐
	분기는 goto DEST로 다시 실행
	
	실행 지속방법은 "다음실행 명령어의 물리적 주소를 지정"
	기호 레이블으로 점프 위치 재지정

8.1.2 서브루틴 호출
	내장형 명령 호출과 사용자 정의 서브루틴 호출의 차이점 : call 키워드
	
	호출자가 인수 설정
	스택에서 인수 삭제, 반환갑싱 스택의 최상위 요소가 됨
	
	지역변수를 임시 저장소로 쓰기도 함
		실행부터 return 시점까지 값이 살이있음 - 그러면 반환값을 메모리에 저장하고 공간을 해제해야하는거 아님?
	
	재귀 호출은 어떻게 할래? - 맨 위의것만 실행되기만 하면 됨 - 후입선출 LIFO
	

	call xxx 구현 시 호출자의 프레임을 스택에 저장
	xxx 지역변수에 스택 공간 할당 후 실행코드로 점프
	
		서브루틴 기호의 주소 확인하고 실행코드로 점프
		return에는 주소가 없다.. 익명성이 필요하지
	! call 명령이 어디에 있든지 그다음 명령으로 점프해서 실행해랴!
	! "반환 주소" : 다음 명령의 메모리 위치
	
	스택으로 처리하면 됨
		호출된 곳 다음 명령 주소가 반환주소가 됨
		반환주소를 스택에 넣고, 호출된 서브루틴을 이어서 실행
		return 명령이 나오면 단순히 저장된 반환주소를 꺼내서 goto로 이동하면 됨

8.2 흐름제어 명령과 함수 호출 명령을 추가

8.2.1 프로그램 흐름 제어 명령
	label label : 위치에 레이블을 붙임
		레이블이 표시된 위치로만 점프가 가능하기에!
	goto label : 무조건 분기
		점프 위치는 같은 함수 내 있어야 함
	if-goto label : 조건 분기
		스택 최상단 값이 0 이 아니면 label 로 표시된 위치에서 실행 계쏙
		0이면 다음 명령을 실행
		
8.2.2 함수 호출 명령	
	함수는 전역적으로 호출할 때 쓰이는 기호로 된 이름을 가짐
	Foo 클래스의 bar 메서드는 Foo.bar 로 번역되어야 함...
	! 모든 파일 내의 함수 이름이 공유됨

8.3 구현
8.3.1
	전역 스택 : vm 메모리 자우너은 전역스택으로 구현
		함수 호출 시 스택에는 새로운 블록 추가
			-구성 : 포인터들, 징겨변수들, 빈 작업 스택으로 구성
			더 쌓는거임 ㅇㅇ
		
		스택 시작 점 sp = 256 으로 설정
	

프로젝트
7장에서 만든것 보완하면 됨
	
	
	